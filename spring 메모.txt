** 250812

new spring starter project

maven
war
21
java

aaa.bbb.ccc
기업.기업.프로그램

aaa.bbb group
ccc artifact

major.minor.patch
상위 버전이 오르면 하위 버전은 초기화
메이저 - 기존과 시스템이 달라 업데이트 요구
마이너 - 업데이트 안 해도 됨

spring web

project -> run as -> spring boot app

1521, 2030, 8080 오라클 사용 중 port
오라클 port -> 9090으로 변경

dbeaver에서 관리자로 로그인
select dbms_xdb.gethttpport() from dual; // 포트 확인
call dbms_xdb.sethttpport(9090); // 포트 수정

package com.kh.spring01;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController 
{
	@RequestMapping("/")
	public String home() 
	{
		return "Welcome to Spring Boot";
	}
}

http://localhost:8080/ = 마지막 / = @RequestMapping("/")

project -> spring -> add devtools

maven 덕에 자동으로 라이브러리 추가

pom.xml
eXtend Markup Language

<!-- Maven의 모델 버전-->
xml의 주석 방법


프로젝트에서 사용하는 외부 의존성
 - 이곳에 작성된 라이브러리는 maven이 자동으로 다운받아 저장
 - maven dependencies

build 배포파일을 만들 때 사용하는 도구

// 강사님 블로그
https://docs.sysout.co.kr/database/oracle

target 폴더 ->  빌드랑 연관

src -> source

src/main/java java 파일 놓는 곳
src/test/java 임시 파일 놓는 곳
src/main/resource java는 아니지만 프로그램에 영향을 주는 파일들
src/main/webapp

Spring02Application // 만지면 안됨 - 지워도 안됨

ServletInitializer.java -> war를 선택해서 자동으로 생성

깃 연동 후 alt + f5로 빌드를 다시 해야함

이클립스 우측 상단에 java <-> git 전환 버튼이 있음. 여기에 git 연동하기

새 프로젝트 생성 -> team -> share project

request <-> response
요청		응답

등록을 해야 사용이 된다
@RestContoller, @Controller, @RequestMapping

의존성 주입(injection)

inversion of control, 제어 반전이라고 한다(스프링의 제 1특징)

query parameter

예제 : http://localhost:8080/quiz01?cream=5&nutella=2

quiz01 등록한 함수 이름 
? 뒤 파라미터
cream, nutella 파라미터 이름
5, 2 파라미터 값
& AND 연산자

class 위 선언

@RequestMapping("/quiz") // 공용 주소
@RequestMapping("/quiz01") // 개별 주소

http://localhost:8080/quiz/quiz01


public String Quiz01(@RequestParam(required = false, defaultValue = "0") int cream, 
@RequestParam(required = false, defaultValue = "0") int nutella)
cream과 nutella가 없어도 되게 한다

// ctrl + space


public int quiz02(@RequestParam(required = false) Integer year) 
{
	if (year == null)
		return 1550;
}


application.properties

# main configuration file
# key=value

spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.url=jdbc:oracle:thin@localhost:1521:xe
spring.datasource.username=kh16
spring.datasource.password=kh16

Oracle Driver
Spring Data JDBC

오라클 연동

@Autowired
private JdbcTemplate jdbcTemplate;

Dto는 1회용 취급, 등록하지 않는다

@Repository
Dao를 등록한다

@Component
Mapper를 등록한다

dataSource -> jdbcTemplate > pokemonDao
pokemonMapper > pokemonDao
pokemonDao > controller

com.kh.spring04jdbc.


// 객체를 달라고 하면 객체 내부의 필드값을 달라는 소리로 해석된다
// 이때는 @ModelAttribute라고 선언한다
@RequestMapping("/add")
public String add(@ModelAttribute PokemonDto pokemonDto) 
{
	pokemonDao.insert(pokemonDto);
	return "포켓몬 등록 완료";
}

@Controller: 요청 처리 도구(결과가 화면)
@RestController : 요청 처리 도구(결과가 데이터)
@RequestMapping("/페이지추가") : 주소 설정 도구
PokemonController

@Repository : 데이터베이스 제어 도구(DAO)
PokemonDao

@Conmponent : 단위 작업 도구(유틸, 혼자 작동하는 도구들)
PokemonMapper

@ModelAttribute 매개변수 : 파라미터를 객체로 한 번에 서신 || Controller만 사용 가능
@RequestParam 매개변수 : 요청 파라미터 변수

@Service : 작업 그룹 (서비스라 부를 수 있는 복잡한 행위)

@Autowired : 등록된 대상을 가져와서 사용하도록 해주는 코드

application.properties

# main configuration file
# key=value

spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=kh16
spring.datasource.password=kh16



Oracle Driver
Spring Boot DevTools
Spring Data JDBC
Spring Web


jdbcTemplate.update(); // db에 변화를 일으키는 작업

** 250819

Java EE -> Spring
주방 백엔드
홀 프론트엔드
 - JSP(배울 것), Thymeleaf(사용 중), Velocity, 
 - CSR(React(배울 것), Vue)

컨트롤러 쓰려면 Spring Web
Maven Update -> alt + f5
1
123

123


** 250819

			<scope>test</scope>
		</dependency> <!-- 아래에 추가-->
		<!-- JSP사용을 위해 추가하는 의존성(추가 후 메이븐 업데이트 및 서버 재시작) -->
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
</dependency>
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
</dependency>
<dependency>
    <groupId>org.glassfish.web</groupId>
    <artifactId>jakarta.servlet.jsp.jstl</artifactId>
</dependency>
<dependency>
    <groupId>jakarta.servlet.jsp.jstl</groupId>
    <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
</dependency>


src/main/webapp/WEB-INF(이름 중요, 다른 이름 허용 안함)/views


**
new > other > jsp 없음

**
help -> eclipse marketplace -> web -> eclipse enterprise java and web developer tools 3.37
다운 중 신뢰하냐고 묻는 말에 모두 동의. 동의 안하면 다운이 안됨

**
new > other > jsp 생김

**

@Controller
public class ViewController 
{
	@RequestMapping("/hello")
	public String hello()
	{
		return "/WEB-INF/views/hello.jsp";
	}
}


 JSP 
 - Java Server Page(자바를 기반으로 만든 화면)
 - 자바 코드와 html을 섞어서 사용 가능
 - html을 먼저 배우고 자바 코드를 섞는 방법을 배운다
 - 맨 위에 작성되는 것은 지우면 안된다
 - contentType은 사용자가 받을 화면의 형태를 저장한다
 - (MIME-TYPE, text/html, video/mp4, text/plain, 대분류/소분류)
 - pageEncoding은 내부적으류 변환할 때 적용시킬 글자셋을 의미



<h1>1번 예제</h1>

<%--
Hyper Text Markup Language
- text끼리 얽힌 게 Hyper Text
- 태그. 미리 정의된 tag를 이용하여 구현(지정된 영역에 정해진 효과 부여)
- a 태그는 클릭하면 다른 페이지로 이동하는 하이퍼태그
- 태그 만으로 정보가 부족할 때 속성을 사용하여 추가 정보를 제공
--%>

아무런 태그 없이 작성한 일반 글자
<h1>태그로 감싼 글자</h1>
<h2>태그로 감싼 글자</h2>
<h3>태그로 감싼 글자</h3>
<hr> 구분선

<h4>태그로 감싼 글자</h4>
<h5>태그로 감싼 글자</h5>
<h6>태그로 감싼 글자</h6>
<marquee direction="left" scrollamount="5">
  흐르는 글자 예시
</marquee>
<marquee direction="right" scrollamount="5">
  흐르는 글자 예시2
</marquee>
<a href = "https://naver.com">네이버로 이동</a>
<a href = "http://localhost:8080/hello">hello로 이동</a>
<a href = "./hello">hello로 이동</a>
<a href = "hello">hello로 이동</a>

마지막 / -> endPoint

이미지 태그
<img src = "link" width="pixel" height="pixel">123
width="50%"
</img>가 없음

<a href ="#"></a>
# : 이동은 안 되지만 링크처럼 보인다

online dummy image

Lorem Picsum
-https://picsum.photos/
-https://picsum.photos/id/#/#/#
id, width, height

src/main/resources
static 아래에 이미지를 넣으면 바로 올릴 수 있음


입력창 만들기
- input, select, textarea
- input은 button으로 가능
- </input> 없음
- 외부에 form 태그를 만들어서 입력창과 버튼을 묶고 전송하도록 설정한다

<form>
<input>
<button></button>
</form>

action 공용 주소
name form에서 입력한 값이 적용될 부분

<form action = "https://genie.co.kr/search/searchMain">
<input name = "query">
<button>전송</button>
</form>

<form action = "https://www.youtube.com/results">
<input name = "search_query">
<button>전송</button>
</form>

<form action = "https://github.com/search">
<input name = "q" placeholder = "자동으로 써있는 문구">
<input type = "hidden" name = "type" value = "repositories">
<button>검색</button>
</form>

<form action = "https://www.coupang.com/np/search">
<input type = "hidden" name = "component" value = "">
<input name = "q">
<input type = "hidden" name = "channel" value = "user">
<button>검색</button>
</form>

<!-- select는 보기(option)를 주고 그 중에서 선택하여 입력한다 -->

<h1>쿠팡 검색창</h1>

<form action = "https://www.coupang.com/np/search">
<!-- <input type = "hidden" name = "component"> -->
	<select name = "component">
		<option value = "">전체</option>
		<option value = "564553">패션의류/잡화</option>
		<option value = "176422">뷰티</option>
		<option value = "194176">식품</option>
	</select>
	<input type = "text" name = "q" placeholder = "상품명을 입력하세요">
	<input type = "hidden" name = "channel" value = "user">
	<button>검색</button>
</form>


"redirect:add3"; 새로고침에 대응 || add3 Mapping 이름


@Controller가 아닌 @RestController를 import하면 jsp파일을 못 찾는다

<input inputmode = "numeric"></input> // 모바일에서 우선된다.

** 250820

miroboard
다이어그램 제작 프로그램

ERD - Entity Relational Diagram 	데이터베이스 관계도
Flow Diagram 			홈페이지 흐름도
Usercase Diagram 		사용자별 이용현황
UI tool (figma)			화면 설계도구
Memo tool (notion)		문서 공유 시스템
Profile tool (형상관리, github)	형상관리 시스템

홈페이지 요청 방식(Request Method)
 - 홈페이지에 대한 요청이 다양할 수 있기에 용도별로 이름 구분
 - GET 방식 : 홈페이지 기본 요청 방식(주소를 이용한 요청)
 - POST방식 : 대용량 데이터 전송을 위한 요청 방식 (ex : 파일)
 - 그 외에도 PUT, PATCH, DELETE, OPTIONS, TRACE, HEAD 등 다양
 - GET, POST는 기본적으로 제공되는 태그에서 사용 가능
 - 나머지는 자바 스크립트를 배워야 함
 - (중요) 주소가 같아도 방식이 다르면 공존 가능
 - 제출하는 페이지를 POST로 개선

 - ADD1, ADD3 GET, ADD2 POST

@RequestMapping -> @GetMapping, @PostMapping
@RequestMapping(value = "/add", method = RequestMethod.GET)
@RequestMapping(value = "/add", method = RequestMethod.POST)

url 쳐서 들어가면 get이 기본이다

<form action = "./add" method = "post">
</form>

forward와 redirect의 차이
forward : 화면이 필요할 때 URL은 바뀌지 않음
redirect : 화면을 튕겨낼 때 URL이 바뀜

목록
표를 만드려면 태그가 많이 필요함
    <table>
    <thead>번호</thead> 제목
    <tbody>1</tbody> 내용
    <tfoot></tfoot> 태그로 하단 정보 영역을 지정
    <tr></tr> 한 줄을 생성
    <th> 태그로 칸을 생성 (제목, 가운데 정렬, 굵은 글씨)
    <td> 태그로 칸을 생성 (내용, 왼쪽 정렬 , 일반 글씨)
    </table>

    <table border = "1" width = "500">
    <thead>
    <tr>
    <th></th>
    </tr>
    </thead>
    <tbody align = "center">
    <tr>
    	<td>1</td>
    </tr>
    </tbody>
    </table>

<tbody align = "center">를 쓴다. align 속성이 여럿이면 가장 가까운 게 적용된다

flatuicolors.com/palette/us

bgcolor = ""

컨트롤러의 역할은 단순한 페이지 연결이 아닌 페이지에 필요한 데이터 전달
전달할 데이터가 있다면 매개변수에 Model을 선언
public String list(Model model) 
model.addAttribute("이름", 값) 형태로 전달

model.addAttribute("pokemonList", pokemonList);
${} 표현 언어 Expression Language EL : 받아온 데이터를 쓸 때

이 페이지에서 반복 등 프로그래밍 태그를 사용하도록 설정

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<c:forEach var = "pokemonDto" items = "${ pokemonList }">
	<tr>
		<td>${ pokemonDto.getPokemonNo() }</td>
		<td>${ pokemonDto.getPokemonName() }</td>
		<td>${ pokemonDto.getPokemonType() }</td>
	</tr>
</c:forEach>

<%-- --%>
JSP 주석
<!-- -->
HTML 표준 주석

JSTL(Jsp Standart Tag Library) JSP 표준 태그 모음. 을 사용하여 프로그래밍 처리를 수행
날 것의 자바 코드를 절대로 JSP에 쓰지 않는다

for (int i = 0; i < 10; i++)

var = i;
begin = 0;
end = 10;
step = i++;


<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

JSP가 더 편한 것들
1. 숫자에 컴마 찍기 -> java.text.DecimalFormat : fmt:formatNumber		
<td><fmt:formatNumber value="${studentDto.getStudentAverage()}" pattern="#,##0.00"/></td>

2. 날짜 형식 바꾸기 -> java.time.format.DateTimeFormatter fmt:formatDate

	<td>${ studentDto.getStudentReg() }</td>

column과 keyword의 상태에 따라 ****검색인지 아닌지 판정
boolean isSearch = column != null && keyword != null;

<td><fmt:formatNumber value="${studentDto.getStudentAverage()}" pattern="#,##0.00"/></td>
<td><fmt:formatDate value="${studentDto.getStudentReg()}" pattern="y년 M월 d일"/></td>

<form action = "https://www.coupang.com/np/search">
<!-- <input type = "hidden" name = "component"> -->
	<select name = "component">
		<option value = "">전체</option>

* 페이징 나눈 후 테이블에 검색 결과 조회

<tfoot>
	<tr>
		<td colspan="7">
			검색결과 : 
			${pageVO.begin} - ${pageVO.end}
			/
			${pageVO.dataCount}개
		</td>
	</tr>
	<tr>
		<td colspan="7">
			검색결과 : 
			${pageVO.page} / ${pageVO.totalPage} 페이지
		</td>
	</tr>
</tfoot>	
		<option value = "564553">패션의류/잡화</option>
		<option value = "176422">뷰티</option>
		<option value = "194176">식품</option>
	</select>
	<input type = "text" name = "q" placeholder = "상품명을 입력하세요">
	<input type = "hidden" name = "channel" value = "user">
	<button>검색</button>
</form>

** 250821

client -> 브라우저

브라우저가 다르면 다른 client으로 인식한다

식당 Spring Boot
1 주문, 요청하는 행위를 Client -> Request
2-1 DispatcherServlet 모든 스프링의 행위를 담당
 -> 처리할 수 없는 요청, 없는 주소 404 에러
 -> 옵션 불일치 400 에러

@Controller, @RestController
-> 주방직원
2-2 프로그래밍 처리 지시

DB 
-> 식료품 창고
창고에 다녀오는 행위
-> JDBC

3 다된 음식 -> DispatcherServlet에게 전달
Model

3-2 redirect 302

4 화면 제작 지시
-> Java 코드와 html로 완성된 화면 제작

5 화면 완성

6 정상적으로 만들어진 화면 200
response 응답 -> client


MVC pattern

Model
View
Control


${isSearch ? "검색" : "목록"}

검색 키워드를 input창에 다시 적기
<input type ="search" name="keyword" value = "${keyword}">

스프링 컨트롤러의 Model에서 건네준 값을 jsp에서 쓰려면 ${param}으로 쓸 수 있는데 특정 태그의 내부 옵션 설정이면 "${param}"으로 쓴다

<input type ="text" name="keyword" value = "${keyword}" required="required">
검색어 없이 검색

readonly = "readonly"

select에서 해당 값이 이미 선택되어 있게 한다
selected = "selected"

required, readonly, selected 이름과 설정값이 같은 속성들은 생략 가능


root_package.aop

// (+추가) 이 콘트롤러로 들어오는 empty string은 null이다
@InitBinder // 콘트롤러가 미리 알아야 하는 내용을 알려주기 위한 메소드(전처리 메소드)
public void InitBinder(WebDataBinder binder) 
{
	// binder.registerCustomEditor(데이터 종류, 사용할 도구);
	binder.registerCustomEditor(String.class, new StringTrimmerEditor(true));
}

<select name="column">
	<option value="book_title" ${column == "book_title" ? "selected" : ""}>책 제목</option>
	<option value="book_author" ${column == "book_author" ? "selected" : ""}>저자</option>
	<option value="book_publisher" ${column == "book_publisher" ? "selected" : ""}>출판사</option>
</select>

검색을 해도 선택한 드롭박스가 유지된다

EL, JSTL null을 유연하게 처리


JSP에서 if 쓰기
<c:if test= "${studentDto == null}">
<h3>존재하지 않는 학생 정보입니다.</h3>
</c:if>

JSP에서 if else 쓰기
<c:choose>
<c:when test="${bookDto == null}"></c:when>
<c:otherwhen></c:otherwhen>// 여기에는 test 설정 불가. 위가 아니라면 들어온다
</c:choose>


함수 throws Exception
throw new Exception("에러상황"); // unchecked exception
throw new RuntimeException("존재하지 않는 포켓몬 번호"); // checked exception

package com.kh.spring09home.error;

// 사용처 : 대상이 없어서 더 이상 진행할 수 없는 경우 사용하는 커스텀 예외
public class TargetNotfoundException extends RuntimeException
{
	//private static final long serialVersionUID = 1;
	public TargetNotfoundException() 
	{
		super();
		// TODO Auto-generated constructor stub
	}

	public TargetNotfoundException(String message) 
	{
		super(message);
		// TODO Auto-generated constructor stub
	}
}


** 250822

헤더 템플릿 페이지
메인 페이지 -> 포켓몬, 학생, 도서 테이블이랑 연결
푸터 템플릿 페이지

HTML 5

<%--비어있는 블럭 생성(div)--%> 

헤더와 푸터 합치기

동적 include
<jsp:include page="/WEB-INF/views/template/header.jsp"></jsp:include>
header.jsp		header.java		header.class
home.jsp		변환	home.java	 컴파일	home.class	합체	실행
footer.jsp		footer.java		footer.class
서로간의 영향 없이 화면만 붙이고 싶을 때 쓴다

정적 include
<%@ include file = "/WEB-INF/views/template/footer.jsp"%>
header.jsp 		
home.jsp		합체&변환	home.java	컴파일		home.class	실행
footer.jsp
의존도가 높다(강한 결합) - 요즘은 비선호

템플릿 페이지에서 작성하는 경로는 반드시 절대 경로여야 한다

<a href = "/">Home</a>
<a href = "/pokemon/list">Pokemon</a>
<a href = "/student/list">Student</a>
<a href = "/book/list">Book</a>


<pre> 엔터 등 사용자가 입력한 내용들을 그대로 출력하는 태그</pre>

Lombok
Project 우클릭 > Spring > add starters
pom.xml에 lombok 추가
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

@Setter @Getter @ToString @NoArgsConstructor

@Data
public class Dto
@ToString(exclude = {"memberPw"})


C:\Users\user1\.m2\repository\org\projectlombok\lombok

java -jar lombok-1.18.38.jar

1. 제어반전
2. 의존성 주입
3. ???
4. POJO 암것도 없는 자바 객체

아래로
rowspan
오른쪽으로
colspan


파라미터 정도는 별도의 선언 없이도 쓸 수 있다
param.


member/login get
로그인 정보 입력

member/login post
로그인 판정
로그인 성공시 첫 페이지로

** 250825

select * from member where member_id
select * from member where member_id and member_pw

2번쨰는 쓰면 나중에 암호화 때 문제가 생긴다

홈으로 이동시킨다
redirect:/

testuser1
Testuser1!
테스트유저1
testuser1@kh.com

정상접근 /member/login
이상접근 /member/login?error


@PostMapping("/login")
public String login(@ModelAttribute MemberDto memberDto)
//public String login(@RequestParam String memberId, 
//		@RequestParam String memberPw) 
{
	MemberDto findDto = memberDao.selectOne(memberDto.getMemberId());
	if (findDto == null)
		return "redirect:login?error";
	
	boolean isLogin = findDto.getMemberPw().equals(memberDto.getMemberPw());
	if (isLogin)
		return "redirect:/";
	else
		return "redirect:login?error";
}

${ param.error }

<!-- error 파라미터가 있다면 오류 메세지 출력 -->
<c:if test = "${ param.error != null }">
	<h2 style = "color:red">입력하신 정보가 일치하지 않습니다.</h2>
</c:if>

HttpSession : Map<String, Object>

public String login(@ModelAttribute MemberDto memberDto, 
			HttpSession session)

HttpSession은 서버에서 사용자마다 부옇는 공간의 모음
최소 30분은 유지
스프링 컨트롤러에서 달라고 하면 주입해준다 > 자유롭게 사용 가능
데이터 추가 setAttribute
데이터 제거 removeAttribute
데이터 확인 getAttribute

session.setAttribute(이름,  값);
session.setAttribute("loginId",  findDto.getMemberId());
session.setAttribute("loginLevel",  findDto.getMemberLevel());

@RequestMapping("/logout")
public String logout(HttpSession session) 
{
	session.removeAttribute("loginId");
	session.removeAttribute("loginLevel");
	return "redirect:/";
}

세션ID : ${pageContext.session.id} - loginId : ${sessionScope.loginId} , loginLevel : ${sessionScope.loginLevel}

<c:if test = "${ sessionScope.loginId == null }">
		<a href = "/member/login">로그인</a>
</c:if>
<c:if test = "${ sessionScope.loginId != null }">
		<a href = "/member/logout">로그아웃</a>
</c:if>

주소를 통한 비화원의 관리자 기능 접근 차단

Upcasting, Downcasting

<fmt:formatDate value="${memberDto.memberJoin}" pattern="y년 M월 d일 H시 m분 s초"/>

회원 탈퇴시 로그아웃도 되어야 한다

redirect는 GET밖에 못 보낸다

삭제 우선. 후 로그아웃

상대경로 ../image/google.png


update는 전반적인 정보 수정에 사용

String loginId = (String)session.getAttribute("loginId");

정보를 변경하는 경우는 크게 두 가지
1. 회원이 자기 정보를 변경
2. 관리자가 회원의 정보를 변경


*** 250826

비정상적인 접근 차단 (주소를 통한 비화원의 관리자 기능 접근 차단)
 -> 인터셉터, 필터(스프링)



@Controller // MVC Controller, View 반환
@RestController // REST API Controller, JSON 등 데이터 반환
@Component // 범용적인 스프링 Bean 등록
@Repository // DB 접근 계층, 예외 변환 기능 포함

@Service // 복합적인 기능을 수행하는 도구

@Autowired를 쓰면 @Service, 안 쓰면 @Component

*** 인터셉터 코드

@Service
public class TestInterceptor implements HandlerInterceptor
{
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println("테스트 인터셉터 실행");
		return false;
	}
}

// application.properties에서 할 수 없는 프로그래밍 설정을 수행한다
@Configuration
public class InterceptorConfiguration implements WebMvcConfigurer
{
	@Autowired
	private TestInterceptor testInterceptor;
	@Autowired
	private MemberLoginInterceptor memberLoginInterceptor;
	
	
	@Override
	public void addInterceptors(InterceptorRegistry registry) // 인터셉터 등록메소드
	{
		registry.addInterceptor(memberLoginInterceptor)
		.addPathPatterns("/student/**", "book/**", "/member/**")
		.excludePathPatterns("/member/join*", 
				"/member/login", "/member/goodbye").order(1);
		
		registry.addInterceptor(advencedMemberInterceptor)
		.addPathPatterns("book/**").order(2);
		
		registry.addInterceptor(adminInterceptor)
		.addPathPatterns("/member/list").order(3);
	}
}

스프링에서는 주소 패턴을 위해 다음과 같은 기호를 제공
*를 이용해서 지정한 대상과 동일한 엔드포인트 내의 모든 항목을 지정
**를 이용해서 지정한 대상과 하위 모든 항목을 지정
/student/add* : /student/add, /student/addFinish 포함
/** 모든 주소 : 

@Service
public class MemberLoginInterceptor implements HandlerInterceptor
{
	@Override
	public boolean preHandle(HttpServletRequest request, // 요청 정보가 담긴 객체, 사용자 정보
			HttpServletResponse response, // 응답 정보가 담긴 객체, 사용자에게 나갈 정보
			Object handler)
			throws Exception {

		// 사용자의 정보를 조회하고 싶을 때는 Request 사용 (파라미터, 세션, 쿠키)
		// 사용자의 결과화면을 제어하고 싶을 떄는 Response 사용 (에러처리, 리다이렉트)
		HttpSession session = request.getSession();
		String loginId = (String)session.getAttribute("loginId");
		// 세션에 loginId가 존재한다면
		boolean isMember = loginId != null;
		
		System.out.println("멤버 로그인 인터셉터 실행");
		if (isMember) // 회원이면
		{
			return true;			
		}
		else 
		{
			// 차단하기 전에 사용자에게 보여줄 내용을 설정하도록 구현
			// [1] 로그인 페이지로 리다이렉트 - 화면을 JSP로 만들 때 유용
			// response.sendRedirect("/member/login");
			// [2] http 표준 상태번호를 전송 - 화면을 다른 기술러 구현할 때
			// response.sendError(401);
			// [3] 예외처리(가장 권장) - 예외 클래스를 만들어야 함
			// throw new UnauthorizationException("로그인이 필요합니다.");
			return false;
		}
		
	}
}


***

http 표준 상태번호
1xx 실시간 연결
2xx 성공
3xx 다른데로 이동
4xx 없거나 안됨
5xx 오류


InterceptorConfiguration.order(int);

** 에러페이지

4xx, 5xx이 에러 취급
4xx은 상황상 안되는 경우
5xx는 만들다 에러가 발생한 경우

Spring의 핵심부품인 DispatcherServlet을 기준으로 봤을 때
4xx은 DispatcherServlet이 일을 시킬 대상이 없는 것
 = 컨투롤러가 실행이 안된 상황
5xx은 DispatcherServlet이 일을 시켰는데 문제가 생긴 것
 = 컨트롤러가 실행이 된 상황
 = 스프링에서 처리해야 하는 핵심적인 에러

컨트롤러어드바이스

error 페이지는 무조건 절대경로여야 한다

e.getMassage();

@ControllerAdvice
public class ExceptionControllerAdvice 
{
	@ExceptionHandler(TargetNotfoundException.class)
	public String notFound(TargetNotfoundException e, Model model	) 
	{
		// 컨트롤러에서 작성 가능한 코드라면 뭐든지 가능
		model.addAttribute("title", e.getMessage());
		return "/WEB-INF/views/error/notFound.jsp";
	}
}

JSP에서 ${ title }로 사용 가능


@ControllerAdvice.@ExceptionHandler(Exception.class)

 *** 250827

intercetor

preHandle

200 성공
400 파라미터 불일치
401 미인증(권한부족)
404 없는 주소 요청

postHandle
afterCompletion
직접 만들 일은 없다

인터셉터 : 요청과 응답 사이에 간섭할 수 있는 객체
필터 : 요청 전에 간섭할 수 있다


통계 작업

테이블의 데이터를 요약해서 새로운 정보를 만들어내기 위한 명령 함수
소속 되어야 하는 건 메소드
혼자 있을 수 있는건 함수
count, sum, avg, min, max
select * from pokemon;

length(pokemon_name)
upper(pokemon_name)
집계함수는 데이터를 요약해서 반환하므려 결과의 데이터 개수가 다르다

select count(*) from pokemon;

single-row는 기존 데이터 불러오기랑 같이 쓸 수 있지만
aggregage는 단독으로만 쓸 수 있다

그룹을 만들고 싶다면 조회 뒤에 group by를 적어서 묶을 항목을 지정한다
select book_genre 장르, count(*) 권수, min(book_price) 최저가, max(book_price) 최고가, avg(book_price) 평균가 from book group by BOOK_GENRE ;

select distinct book_genre from book;
중복 제거 distinct

* 별칭 정하기에서 ""가 있으면 띄어쓰기를 적을 수 있다

별칭을 통일하여 한 번에 처리하도록 변경

select member_level 회원등급, count(*) 등급별인원수, sum(member_point) 포인트합계 from member group by member_level;

>

select member_level title, count(*) value from member group by member_level;
select book_genre title, count(*) value from book group by book_genre;
select pokemon_type title, count(*) value from pokemon group by pokemon_type;

* Dto : 테이블을 옮겨담기 위한 도구

* 통계를 위한 Value Object

package com.kh.spring09home.vo;

import lombok.Data;

// Value Object
// 테이블이 아닌 데이터를 내 입맛에 맞게 모아서 사용하고자 할 때 만드는 클래스
@Data
public class StatVO 
{
	private String title;
	private double value;
}

select pokemon_type, count(*) from pokemon group by pokemon_type having count(*) >= 10;

그룹에 사용할 값을 계산을 통해 만들어냄(ex:날짜, 숫자)

select extract(year from student_reg) title, count(*) value from student group by extract(year from student_reg) order by value desc, title asc;

* 구문 해석 순서
[select] [항목] [from 대상] [group by 항목] [order by 정렬]
[1] [4] [2] [3] [5]

FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순서로 해석

to_char(timestamp, 'YYYY-MM-DD HH24:mm:SS')

앞으로 할 것------------------------

관리자의 포인트 상품권 crud

회원의 포인트 상품권 구매

자유 게시판

자바스크립트 + 제이쿼리
좋아요, 이메일 인증
---------------------------------------

게시판의 정의
- 글 또는 미디어를 다른 사용자들과 공유할 수 있는 저장 시스템

우리가 만들 게시판은 텍스트 위주의 게시판
(향후 첨부파일 등 업그레이드)

작성자와 비멀번호까지 입력하는 글을 쓰는 익명 게시판
회원 정보가 자동으로 연동되는 회원 게시판

외래키(Foreign Key)
다른 테이블의 특정 항목을 참조하는 컬럼
게시글의 작성자는 회원의 아이디
만약에 존재하지 않는 회원의 아이디를 작성자로 등록한다면 오류가 발생
회원이 탈퇴하면 게시글을 어떻게 처리할지에 따라 외래키 생성조건이 달라진다
 - 회원이 탈퇴하면 글을 삭제해야 할 경우 'on delete cascade' 사용
 - 회원이 탈퇴하면 글의 작성자만 지우도록 할 경우 'on delete set null' 사용
 - 별도의 처리를 안 하면 게시글을 모두 지워야 탈퇴가 가능하다

varchar2(4000)
char(2000) 

테이블 board

| 항목 | 이름 |  형태 | 설명

글번호 | board_no | 숫자 | 기본키, 시퀀스로 적용
글제목 | board_title | 한글 100자 이내 | 필수항목
작성자 | board_writer | 회원 아이디 | 탈퇴하면 null로 설정
작성일 | board_wtime | 날짜 | 등록시점에 현재 시각으로 설정
수정일 | board_etime | 날짜 | 등록시점에는 null이고 수정할 때 현재 시각으로 설정
글내용 | board_content | varchar2(4000) | 필수 항목
조회수 | board_read | 숫자 | 등록시 0. 읽을 때마다 +1
좋아요 | board_like | 숫자 | 등록시 0.
댓글수 | board_reply | 숫자 | 등록시 0.
공지여부 | board_notice | y/n | 별도의 처리가 없으면 n으로 설정

글제목, 글내용만 입력
시퀀스 이름은 board_seq
옵션은 기본 옵션

BoardDao
BoardDto
BoardMapper
BoardController

/board/list 목록 보기
/board/detail 상세 보기
/board/write 글 작성
/board/edit 글 수정
/board/delete 글 삭제

글 작성 후 상세로 가는게 일반적이지만 목록으로 가면 난이도 하락

상세보기
-> 글쓰기
-> 수정
-> 삭제
-> 목록
-> 이동(관리자 기능)
-> 답글(미구현)

referencs 테이블(컬럼명)


* 쿼리문 반복문
BEGIN
  FOR i IN 50..90 LOOP
    INSERT INTO "KH16"."BOARD" (
      "BOARD_NO",
      "BOARD_TITLE",
      "BOARD_WRITER",
      "BOARD_CONTENT",
      "BOARD_NOTICE"
    ) VALUES (
    	board_seq.nextval,
      '페이징용제목' || i,
      'testuser' || i,
      '페이징용내용' || i,
      'N'
    );
  END LOOP;
END;

*** 250829

boardContent가 커서 list가 부담이 되면 Mapper를 하나 더 만든다
<%-- 페이지 네비게이터 --%>
<h2>이전 1 2 3 4 5 6 7 8 9 10 다음</h2>

<form action="list">
	<select name="column">
		<option value="board_title" ${param.column == 'board_title' ? 'selected' : ''}>제목</option>
		<option value="board_writer" ${param.column == 'board_writer' ? 'selected' : ''}>작성자</option>
	</select>
	<input type="text" name="keyword" value="${param.keyword}" required>
	<button>검색</button>
</form>

<c:choose>
	<c:when test="${ boardDto.nextDay() }">
		<td><fmt:formatDate value="${boardDto.boardWtime}" pattern="yyyy-MM-dd"/></td>
	</c:when>				
	<c:otherwise>
		<td><fmt:formatDate value="${boardDto.boardWtime}" pattern="HH:mm"/></td>
	</c:otherwise>
</c:choose>

public boolean nextDay() 
{
	LocalDateTime wtime = boardWtime.toLocalDateTime();	
	LocalDateTime now = LocalDateTime.now();
	Duration d = Duration.between(wtime, now);
	return d.toDays() >= 1;
}


게시글의 작성일 = 오늘 날짜

LocalDateTime wtime = boardWtime.toLocalDateTime();	

// 날짜
return wtime.toLocalData().toString()

// 시간
return wtime.toLocalTime().toString()

* 날짜비교

public String getBoardWriteTime() 
{
	LocalDateTime wtime = boardWtime.toLocalDateTime();//작성시점을 LocalDateTime으로 변환
	LocalDate today = LocalDate.now();//오늘날짜를 구하고
	LocalDate wday = wtime.toLocalDate();//작성일자를 구해서
	
	if(wday.isBefore(today)) 
	{	//이전에 작성한 글이라면
		return wtime.toLocalDate().toString();//날짜 반환
	}
	else 
	{
		DateTimeFormatter fmt = DateTimeFormatter.ofPattern("HH:mm");
		return wtime.toLocalTime().format(fmt);//시간 반환
	}
}

@ExceptionHandler(value = {TargetNotfoundException.class, NoResourceFoundException.class})

* textarea

<textarea name = "boardContent" rows="5" cols="110" required></textarea>

<textarea>는 사이에 공백, 줄바꿈이 있으면 안 된다</textarea>

줄 바꿈과 띄어쓰기를 그대로 적용하기 <pre> 사용
<pre>
	<h1>본문 : ${boardDto.boardContent }</h1>
</pre>


select max(board_no) from board;
쓰지 말 것

* 쓰고 번호를 꺼내는게 아니라 번호를 꺼내고 등록한다

select board_seq.nextval from dual;

int처럼 자바의 기본데이터들은 Mapper 없이도 조회 가능
public int insertSequence() 
{
	String sql = "select board_seq.nextval from dual";
	return jdbcTemplate.queryForObject(sql, int.class);		
}

return type에 따라 .class가 바뀐다

기존의 board_seq.nextval는 ?로 수정한다.

게시글 작성 후 리스트로 가면 무쓸모, 상세페이지로 가면 insertSequence를 써야 함

* dual 테이블
아무런 데이터도 안 들어있는 채 조회용 테이블

** 250901


* sessionScope

<c:choose>
	<c:when test = "${ sessionScope.loginId != null }"></c:when>
	<c:otherwise></c:otherwise>
</c:choose>
*  JSP에서 로그인 여부


@Service // 복합적인 기능을 수행하는 도구

* getRequestURI()
-> localhost:8080/ 제외
-> 현재 가려는 페이지를 알 수 있다

String uri = request.getRequestURI();
if (loginLevel.equals("관리자") && uri.equals("/board/delete"))
	return true;

조회수 중복 증가 방지
 - 평생에 1번		DB필요	(아이디, 글 번호)			-> 가벼운 DB(NoSQL - MongoDB)
 - PC마다 1번		DB필요	(IP, GPS, 글 번호)			-> 가벼운 DB(NoSQL - MongoDB)
 - 브라우저마다 1번	DB필요	(브라우저 시리얼번호, 글번호)	-> 가벼운 DB(NoSQL - MongoDB)
 - 일정시간마다 1번	세션, 쿠키


HttpSession session = request.getSession();
String loginId = (String) session.getAttribute("loginId");
int boardNo = Integer.parseInt(request.getParameter("boardNo"));

BoardDto boardDto = boardDao.selectOne(boardNo);
if (boardDto == null)
		throw new TargetNotfoundException("존재하지 않는 게시글");
if (loginId != null && boardDto.getBoardWriter() != null) 
{
	if (loginId.equals(boardDto.getBoardWriter())) 
	{
		return true; // 내 글일 때는 그냥 통과
	}
}

String loginLevel = (String)session.getAttribute("loginLevel");
if (loginLevel != null && loginLevel.equals("관리자")) 
{
	return true; // 관리자는 조회수가 오르지 않는다
}

Set<Integer> history = (Set<Integer>)session.getAttribute("history");
if (history.contains(boardNo))
	return true;
else
	history.add(boardNo);
session.setAttribute("history", history);


* jsp에서 equals 대신하는 구문
<c:when test="${ sessionScope.loginLevel eq '관리자' }">

* DB 최적화 기술 dbcp(database connection pool)
spring.datasource.dbcp2.max-total=20 // 최대 연결 수
#spring.datasource.dbcp2.min-idle=5 // 항상 켜놓는 최소 연결 수
spring.datasource.dbcp2.max-idle=5 // max는 반드시 켜놔야 한다

application.properties에서 설정한다

* 서브쿼리, rownum

-- Top N Query
-- 일반 구문인데 유일하게 이름이 붙은 구문
-- 서브쿼리(sub query)라는 것을 선행식으로 알아야 함


-- 가장 비싼 도서의 이름?
-- max(book_price) 그룹 함수
select book_title from book where book_price = (select max(book_price) from book);
서브쿼리는 구문을 중첩시켜서 순차적으로 실행. 한 번에 작업을 완료할 수 없는 경우

Top N Query는 Top3, Top5, Top10처럼 데이터를 특정 개수만큼 잘라서 조회하는 구문
오라클에서는 데이터의 순서를 알려주기 위해 rowNum이라는 항목을 제공한다
rowNum은 구멍이 없이 연속적으로 채워진다

select rowNum, board_no, board_title from board where rowNum between 1 and 10;
select rownum, board.* from board where rownum between 1 and 10 order BY  board_no desc;
> 
select rownum, board.* from board where rownum between 11 and 20 order by board_no desc;
rownum은 반드시 1부터 시작해야 한다
조건과 동시에 사용하기가 어려우므로 순서를 나눈다
서브쿼리로 순서를 붙여두고 나중에 조건으로 검사한다

select rownum, board.* from board order by board_no desc;
select * from (select rownum rn, board.* from board order by board_no desc) where rn between 11 and 20;

// 최근 가입한 회원 10명 조회

select * from member order by membr_join desc;
select * from (select rownum rn, member.* from member order by member_join desc) where rn between 1 and 10;

기존에 사용하던 구문을 넣으면 자동으로 잘릴 수 있도록 번호 생성 및 조건 부분을 분리

***** select 조회 구문 최종

select * from ( 
	select rownum rn, tmp.* from (
		select * from board order by board_no desc
	) tmp
) where rn between 11 and 20;

* JUnit
adapter lib : spring-test
junit-jupiter, spring-test

** 250902

public List<BoardDto> selectListWithPaging(int page, int size, String column, String keyword) {
	int begin = page * size - (size-1);
	int end = page * size;
	String sql = "select * from ("
		+ "select rownum rn, TMP.* from ("
			+ "select "
				+ "board_no, board_title, board_writer, board_notice,"
				+ "board_wtime, board_etime, board_read, board_like, board_reply "
				+ "from board "
				+ "where instr(#1, ?) > 0 "
				+ "order by board_no desc"
			+ ")TMP"
		+ ") where rn between ? and ?";
	sql = sql.replace("#1", column);
	Object[] params = {keyword, begin, end};
	return jdbcTemplate.query(sql, boardListMapper, params);
}

오브로딩에서 같은 파라미터를 먼저 쓴다

import static
클래스.함수에서 함수만 선언해도 된다

이전 1 2 3 4 5 6 7 8 9 10 다음
// 페이지 네비게이터


@RequestParam(required = false, defaultValue = "1") int page,
@RequestParam(required = false, defaultValue = "10") int size,

목록이든 검색이든 페이징으로 분할디므로 하단 네비게이터에 표시해야 한다
MVC 패턴
주소의 파라미터 부분은 검색일 때와 목록일 때가 다르다
목록 : list?page=1&size=10
검색 : list?page=1&size=10&column=board_title&keyword=공부

* JSP에서 for 돌리기
<c:forEach var = "i" begin = "1" end = "10" step = "1">
</c:forEach>

<c:forEach var = "i" begin = "1" end = "11" step = "1">
	<a href = "list?page=${ i }&size=${ size }${ searchParams }">${ i }</a>
</c:forEach>

start +1 || (page - 1) / blockCount * blockCount + 1
finish +10 || (page - 1) / blockCount * blockCount + blockCount

block -> 페이지 네비게이터

int blockCount = 10;
int start = (page - 1) / blockCount * blockCount + 1;
int finish = (page - 1) / blockCount * blockCount + blockCount;

<c:forEach var = "i" begin = "${ start }" end = "${ finish }" step = "1">
	<a href = "list?page=${ i }&size=${ size }${ searchParams }">${ i }</a>
</c:forEach>

1. 현재 페이지는 구분하여 표시 -> 현재 페이지 ${ page == i }
2. 총 페이지 개수만큼 표시
3. 이전과 다음을 표시한다
 -> 이전과 다음은 다르다


<c:forEach var = "i" begin = "${ start }" end = "${ finish }" step = "1">
	<c:choose>
		<c:when test="${ page == i }">
			<a>${ i }</a>
		</c:when>
		<c:otherwise>
			<a href = "list?page=${ i }&size=${ size }${ searchParams }">${ i }</a>
		</c:otherwise>
	</c:choose>
</c:forEach>

이전 : start - 1
<a href = "list?page=${ start - 1 }&size=${ size }${ searchParams }">이전</a>

다음 : finish + 1
<a href = "list?page=${ finish + 1 }&size=${ size }${ searchParams }">다음</a>

start > 1 첫 구간. 이전이 없어야 한다
<c:if test="${ start > 1 }">
	<a href = "list?page=${ start - 1 }&size=${ size }${ searchParams }">이전</a>
</c:if>

finish < totalPage 마지막 구간. 다음이 없어야 한다
<c:if test="${ finish < totalPage }">
	<a href = "list?page=${ finish + 1 }&size=${ size }${ searchParams }">다음</a>
</c:if>



페이지 수 : 검색/목록에 맞는 전체 게시글 수가 필요하다

페이지 수 = (글수 + size - 1) / size + 1

select count(*) from board;
select count(*) from board where instr(board_title, '공부') > 0;

// 페이지 네비게이터를 위한 카운터 구하는 메소드. 검색과 목록 따로.
public int count() 
{
	String sql = "select count(*) from board";
	return jdbcTemplate.queryForObject(sql, int.class);
}

public int count(String column, String keyword) 
{
	String sql = "select count(*) from board where instr(#1, ?) > 0";
	sql = sql.replace("#1", column);
	Object[] params = {keyword};
	return jdbcTemplate.queryForObject(sql, int.class, params);
}

int totalCount = (isSearch) ? boardDao.count(column, keyword) : boardDao.count();
int totalPages = ((totalCount - 1) / size) + 1;

MVC
Model
View JSP
Controller

꼭 필요하지 않더라도 가독성을 올릴 수 있는 메소드들을 추가


@RequestMapping("/list")
public String list(Model model, 
		@ModelAttribute PageVO pageVO) {
	
	List<BoardDto> boardList = boardDao.selectListWithPaging(pageVO);
	model.addAttribute("boardList", boardList);		

	int dataCount = boardDao.count(pageVO);
	pageVO.setDataCount(dataCount);
	
	model.addAttribute("pageVO", pageVO);
	
	return "/WEB-INF/views/board/list.jsp";
}

* Markdown

## 테이블 만들기

| 제목1 | 제목2 | 제목3 |
| :------ | ------: | :------: |
| 항목1 | 항목2 | 항목3 | --- 3개 이상
| 왼쪽 정렬 | 오른쪽 정렬 | 중앙 정렬4 |


erdcloud.com

A가 B를 C하는 것이다
E entity
R relation


** 250903

String sql = "select * from ("
					+ "select rownum rn, TMP.* from ("
						+ "select * from member "
						+ "where instr(#1, ?) > 0 and member_level != '관리자' "
						+ "order by #1 asc, member_id asc"
					+ ")TMP"
				+ ") where rn between ? and ?";

<%-- 페이지 네비게이터 출력 --%>
<jsp:include page="/WEB-INF/views/template/pagination.jsp"></jsp:include>

@RequestMapping("/list")
public String list(Model model, @ModelAttribute(value = "pageVO") PageVO pageVO) 
{
	model.addAttribute("memberList", memberDao.selectListWithPaging(pageVO));
	pageVO.setDataCount(memberDao.count(pageVO));
	model.addAttribute("pageVO", pageVO); // @ModelAttribute에 value 설정시 생략 가능
	
	return "/WEB-INF/views/admin/member/list.jsp";
}

public int count(PageVO pageVO) 
{
	if(pageVO.isList()) 
	{
		return 0;//목록은 데이터가 없다! (회원 검색의 특징)
		//String sql = "select count(*) from member";
		//return jdbcTemplate.queryForObject(sql, int.class);
	}
	else 
	{
		String sql ="select count(*) from member "
				+ "where instr(#1, ?) > 0 and member_level != '관리자'";
		sql = sql.replace("#1", pageVO.getColumn());
		Object[] params = {pageVO.getKeyword()};
		return jdbcTemplate.queryForObject(sql, int.class, params);
	}
}

public List<MemberDto> selectListWithPaging(PageVO pageVO) 
{
	if(pageVO.isList()) 
	{//목록이라면
		return null;//return List.of();//목록은 현재 보여주지 않고 있다
	}
	else 
	{//검색이라면
		String sql = "select * from ("
							+ "select rownum rn, TMP.* from ("
								+ "select * from member "
								+ "where instr(#1, ?) > 0 and member_level != '관리자' "
								+ "order by #1 asc, member_id asc"
							+ ")TMP"
						+ ") where rn between ? and ?";
		sql = sql.replace("#1", pageVO.getColumn());
		Object[] params = {
				pageVO.getKeyword(), pageVO.getBegin(), pageVO.getEnd()
		};//동적할당
		return jdbcTemplate.query(sql, memberMapper, params);
	}
}

* JSP 검색창에서 이전 값 유지하기

<form action="list" method="get">
	<select name="column">
		<option value="member_id" ${param.column == "member_id" ? "selected" : ""}>아이디</option>
	</select>	
	<%-- param이라는 도구를 이용하면 파라미터를 직접 불러올 수 있다 --%>
	<input type="text" name="keyword" value="${param.keyword}" required>
	<button>검색</button>
</form>

		<%-- 페이지 네비게이터 출력 --%>
		<jsp:include page="/WEB-INF/views/template/pagination.jsp"></jsp:include>

* checkbox
<input type = "checkbox" name = "boardNotice" value = "Y">공지사항으로 등록<br>
체크 안 하면 아예 안 넘어간다. 체크하면 Y가 넘어감

오라클 전용
* nvl(?, 'N')

BoardDto
private String boardNotice = "N";

* status 사용

List<BoardDto> boardNoticeList = boardDao.selectListNotice(pageVO);
List<BoardDto> boardList = boardDao.selectListWithPaging(pageVO);

List<BoardDto> result = new ArrayList<>();
result.addAll(boardNoticeList);
result.addAll(boardList);


* JSP에서 status 사용법
<c:forEach var = "boardDto" items = "${ boardList }" varStatus = "status">
<tr bgcolor = "${ status.index < noticeCount ? '#ffeaa7' : ''}">
	<td>${ boardDto.boardNo } (${ status.index })</td>
	
<td><fmt:formatDate value="${boardDto.boardWtime}" pattern="yyyy-MM-dd"/></td>
<td><fmt:formatDate value="${boardDto.boardWtime}" pattern="HH:mm"/></td>

<input type = "checkbox" name = "boardNotice" value = "Y" ${ boardDto.boardNotice == 'Y' ?
		'checked' : ''>

답변형 게시판
그룹 : 원본 글의 번호
순서 : 누구의 답글인지
차수 : 띄어쓰기를 얼마나 할 지

새글
 - 그룹 : 자기의 번호
 - 상위글 : null
 - 차수 : 0

답글
 - 그룹 : 대상글의 그룹 번호
 - 상위글 : 대상의 글 번호
 - 차수 : 대상글의 차수 ++

 - 그룹 : board_group
 - 상위글 : board_origin
 - 차수 : board_depth


* alter table
alter table board add 
(
board_group number not null,
board_origin references board(board_no) on delete cascade,
board_depth number default 0 not null
)

데이터가 있는 테이블은 not null을 쓸 수 없다

update board set board_group = board_no;

alter table board modify board_group not null;
alter table board modify board_depth not null;

* Integer는 Mapper에서 아래와 같이 쓴다
boardDto.setBoardOrigin(rs.getObject("board_origin", Integer.class));


@PostMapping("/insert")
public String insert(HttpSession session,
		@ModelAttribute BoardDto boardDto) {
	String loginId = (String)session.getAttribute("loginId");
	boardDto.setBoardWriter(loginId);
	
	// 검사를 통해 관리자가 아닌데 공지사항을 쓰려고 하면 차단한다
	String loginLevel = (String)session.getAttribute("loginLevel");
	if (loginLevel.equals("관리자") == false && boardDto.getBoardNotice().equals("Y"))
		throw new NeedPermissionException("공지글을 작성할 권한이 없습니다");
	
	int boardNo = boardDao.sequence();//번호를 생성해서
	boardDto.setBoardNo(boardNo);//게시글 정보에 합친다
	
	if (boardDto.getBoardOrigin() == null) 
	{
		boardDto.setBoardGroup(boardNo);
		//boardDto.setBoardOrigin(null);
		//boardDto.setBoardDepth(0);
	}
	else 
	{
		BoardDto findDto = boardDao.selectOne(boardDto.getBoardOrigin());
		boardDto.setBoardGroup(findDto.getBoardGroup());
		// boardDto.setBoardOrigin(findDto.getBoardNo()); // 생략 가능
		boardDto.setBoardDepth(findDto.getBoardDepth() + 1);
	}
	
	boardDao.insert(boardDto);
	return "redirect:/board/detail?boardNo=" + boardNo;
}

게시글은 상하관계가 있다


connect by prior board_no = board_origin
왼쪽 위, 오른쪽 아래

각 그룹의 시작점은 상위글이 없거나 차수가 0인 글이다
start with board_origin is null

정렬할 떄는 연결된 항목을 기준으로 조회하시고 
order siblings by

그룹이 큰 순서부터 나오게 한다
board_group desc

그룹이 같다면 번호를 오름차순으로 정렬한다
board_no asc

String sql = "select * from ("
					+ "select rownum rn, TMP.* from ("
						+ "select "
							+ "board_no, board_title, board_writer, board_notice,"
							+ "board_wtime, board_etime, board_read, board_like, board_reply "
							+ "board_group, board_origin, board_depth "
						+ "from board "
						+ "where instr(#1, ?) > 0 "
						//+ "order by board_no desc"
						+ "connect by prior board_no = board_origin "
						+ "start with board_origin is null "
						+ "order siblings by board_group desc, board_no asc"

+ "order by board_no desc"

를 지우고 아래로 대체한다

+ "connect by prior board_no = board_origin "
+ "start with board_origin is null "
+ "order siblings by board_group desc, board_no asc"


* html 특수문자 코드
&nbsp;

<c:forEach var = "i" begin = "1" end = "${ boardDto.boardDepth }" step = "1">
	&nbsp;&nbsp;
</c:forEach>

* JSP에서 forEach 쓰기
<c:forEach var = "i" begin = "시작" end = "끝" step = "i 증가폭">
</c:forEach>

서버 시작하는 Local 창 -> Boot Dashboard

public class PageVO 
{
	// 필드에 페이징에 필요한 데이터들을 배치
	private int page = 1; // 현재 페이지 번호
	private int size = 10; // 한 페이지에 표시할 데이터 수
	private String column, keyword; // 검색 항목
	private int dataCount; // 총 데이터 수
	private int blockSize = 10; // 표시할 블록 개수
	
	// 계산할 수 있는 Getter 메소드 추가 생성
	public boolean isSearch() 
	{
		return column != null && keyword != null;
	}
	
	public boolean isList() 
	{
		return column == null || keyword == null;	
	}
	
	public String getSearchParams() 
	{
		if (isSearch())
			return "size=" + size + "&column=" + column + "&keyword=" + keyword;
		else
			return "size=" + size;
	}
	
	public int getBlockStart() 
	{
		return (page - 1) / blockSize * blockSize + 1;	
	}
	
	public int getBlockFinish() 
	{
		int number = (page - 1) / blockSize * blockSize + blockSize;		
		return Math.min(getTotalPage(), number);
	}
	
	public int getTotalPage() 
	{
		return (dataCount - 1) / size + 1;
	}
	
	public int getBegin() 
	{
		return page * size - (size - 1);
	}
	
	public int getEnd() 
	{
		return page * size;
	}
	
	public boolean isFirstBlock() 
	{
		return getBlockStart() == 1;
	}
	
	public boolean isLastBlock() 
	{
		return getBlockFinish() == getTotalPage();
	}
	
	public int getPrevPage() 
	{
		return getBlockStart() - 1;
	}
	
	public int getNextPage() 
	{
		return getBlockFinish() + 1;
	}
}

* 250904

테이블 정규화

제 1 정규화
 - 도메인의 원자성을 보장, 컴마 쓰지 마라 > 테이블 분할

table join : 연결된 서로 다른 테이블을 조회시 어떤 기준에 맞게 합치는 행위
 - inner join : 양쪽에 동일하게 존재하는 항목이 있을 경우만 합쳐서 조회(null 제외) null은 버린다
 - outer join : 특정 테이블을 기준으로 조회하여 다른 테이블을 붙여서 조회(null 포함)
select * from board<-member; left join
 ** left outer join 예제)select board.*, member.member_nickname, member.member_level from board left outer join member on member.member_id = board.board_writer;
select * from board->member; right join
 - full outer join : 잘 안 씀

 insufficient privileges; // view 생성 권한이 없다
grant connect, resource, create view to kh16;

create or replace view board_list as 
select  board.board_no, board.board_title, board.board_writer, board.board_wtime,
    board.board_etime, board.board_read, board.board_like, board.board_reply, 
    board.board_notice, board.board_group, board.board_origin, board.board_depth, 
    member.member_id, member.member_nickname, member.member_level from board left outer join member on member.member_id = board.board_writer
connect by prior board.board_no = board.BOARD_ORIGIN 
start with board.board_origin is null 
order siblings by board.board_group desc, board.board_no asc;

create or replace view board_mention as
select  B.board_no, B.board_title, B.board_writer, B.board_wtime,
    B.board_etime, B.board_read, B.board_like, B.board_reply, 
    B.board_notice, B.board_group, B.board_origin, B.board_depth, 
    M.member_id, M.member_nickname, M.member_level, 
    O.board_no origin_no, O.board_title origin_title, O.board_writer origin_writer
from board B
left outer join member M on M.member_id = B.board_writer
left outer join board O on O.board_no = B.board_origin;

파일 업로드

기본방식(application/x-www-form-urlencoded)
GET - 주소?이름=값&이름=값&이름=값
POST - 주소
	(body:이름=값&이름=값&이름=값)
이 방식으로는 전송할 수 없다
파일전송용 방식(multipart/form-data)
 - 파일처럼 하나의 이름에 많은 정보를 담아야 하는 경우 사용하는 방식
 - 기존 데이터도 전송 가능
 - 선언은 form에 enctype 속성을 적어서 작성

text/html
대분류/소분류 : MIME - TYPE

<form action = "test04" method = "post" enctype="multipart/form-data">

* pom.xml은 메이븐의 설정값

application.propreties

MultipartFile file
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

System.out.println("file : " + attach.getName()); // 업로드한 입력창 이름
System.out.println("file : " + attach.getOriginalFilename()); // 파일명
System.out.println("file : " + attach.getSize()); // 파일 크기
System.out.println("file : " + attach.getContentType()); // 업로드한 파일 유형

FS(File System)
파일 저장법 : c:\user\user1을 기본 경로로 지정

File home = new File(System.getProperty("user.home"));
File upload = new File(home, "upload");
if (upload.exists() == false) 
{
	upload.mkdirs();
}
	
File target = new File(upload, attach.getOriginalFilename()); // 저장할 파일의 인스턴스
attach.transferTo(target);

이름 글자수 제한 : 255


create table attachment(
attachment_no number primary key,
attachment_name varchar2(255) NOT NULL,
attachment_size number not null,
attachment_type varchar2(100) not null,
attachment_time timestamp default systimestamp not null
);
create sequence attachment_seq;

MultipartFile은 전송이 안 되어도 데이터가 생긴다

if (!attach.isEmpty()) 
{
	File home = new File(System.getProperty("user.home"));
	File upload = new File(home, "upload");
	if (upload.exists() == false) 
	{
		upload.mkdirs();
	}
			
	File target = new File(upload, attach.getOriginalFilename()); // 저장할 파일의 인스턴스
	attach.transferTo(target);
}

int attachmentNo = attachmentDao.sequence();
AttachmentDto attachmentDto = new AttachmentDto();
attachmentDto.setAttachmentNo(attachmentNo);
attachmentDto.setAttachmentName(attach.getOriginalFilename());
attachmentDto.setAttachmentType(attach.getContentType());
attachmentDto.setAttachmentSize(attach.getSize());

attachmentDao.insert(attachmentDto);

File target = new File(upload, String.valueOf(attachmentNo));
// 파일명의 중복을 막기 위해 원본 파일의 이름은 저장한 후 시퀀스 번호로 갈아치운다

** 250905

JPA (ORM Framework : DB를 편하게 쓰도록 하는 도구)

java.sql -> Spring JDBC 	-> mybatis
			-> JPA

GET은 전송이 안 됨

@Service // 각종 도구들을 주입하여 거대한 목표를 달성하기 위한 복잡한 코드를 메소드로 가지는 도구
// 상품구매 : 회원포인트 검사/차감 + 상품재고검사/차감 + 구매이력기록

@Transactional // 이 메소드를 하나의 트랜잭션으로 간주(이 안에서의 DB 작업은 일괄로 처리/취소)
다 실행 / 다 취소
내부에서 발생하는 DB 처리를 묶음으로 처리

Controller의 상위 : DispatcherServlet

다운로드 코드를 작성하기 위해 알아야 할 배경지식
컨트롤러는 DispatcherServlet은 문자열을 해석해서 필요한 화면을 불러온다
사실은 다른 걸 반환해도 된다

ModelAndView("/WEB-INF/views/file/test1.jsp")

Map.of("hello", "java") == Model model = model.addAttribute("hello", "java");

ResponsEntity라는 걸 반환하면 내가 사용자에게 보낼 응답을 직접 다 설정할 수 있다
이 방식을 사용하면 파일과 같은 특수데이터도 사용자에게 컨트롤러에서 보낼 수 있다


@GetMapping("/download")
public ResponseEntity<ByteArrayResource> download(@RequestParam int attachmentNo) throws IOException 
{
	// DB에서 정보 조회
	AttachmentDto attachmentDto = attachmentDao.selectOne(attachmentNo);
	if (attachmentDao == null)
		throw new TargetNotfoundException("존재하지 않는 파일");
	
	// 파일의 정보 읽기
	File home = new File(System.getProperty("user.home"));
	File upload = new File(home, "upload");
	File target = new File(upload, String.valueOf(attachmentNo));
	
	// java.nio 패키지의 명령
	byte[] data = Files.readAllBytes(target.toPath());
	ByteArrayResource resource = new ByteArrayResource(data);
	
	// 사용자에게 정보(header)와 내용(body)을 담아서 전송
	// 형태를 모르면 application/octet-stream
	// Content-Length는 전송할 파일의 크기
	// Content-Disposition는 body에 담긴 데이터를 어떻게 처리할지
	// inline 으로 작성하면 
	// attachment
	return ResponseEntity.ok()
			.header("Content-Encoding", "UTF-8") // 이건 UTF-8이다
			.header("Content-Type", attachmentDto.getAttachmentType()) // db에 저장된 AttachmentType
			.header("Content-Length", String.valueOf(attachmentDto.getAttachmentSize()))
			.header("Content-Disposition", "attachment; filename=" + attachmentDto.getAttachmentName())
			.body(resource);

	// 다운로드 최종코드
	return ResponseEntity.ok()
			.header(HttpHeaders.CONTENT_ENCODING, StandardCharsets.UTF_8.name())
			.header(HttpHeaders.CONTENT_TYPE, attachmentDto.getAttachmentType())
			.contentLength(attachmentDto.getAttachmentSize())
			.header(HttpHeaders.CONTENT_DISPOSITION, 
				ContentDisposition.attachment().filename(attachmentDto.getAttachmentName(), StandardCharsets.UTF_8).build().toString())
			.body(resource);
}

Microsoft 949

drop table pokemon_image;
create table pokemon_image 
(
pokemon_no references pokemon(pokemon_no) on delete cascade not null unique,
attachment_no references attachment(attachment_no) on delete cascade not null unique,
primary key(pokemon_no, attachment_no) -- 같은 몬스터가 같은 이미지를 쓸 수 없다
);


<input type = "file" name = "attach" accept = ".png,.jpg">

public int sequence() 
{
	String sql = "select pokemon_seq.nextval from dual";
	return jdbcTemplate.queryForObject(sql, int.class);
}

// 포켓몬 번호를 받아서 프로필 이미지 주소로 쫓아내는 매핑 구현
@GetMapping("/image")
public String image(@RequestParam int pokemonNo) 
{
	int attachmentNo = pokemonDao.findAttachment(pokemonNo);
	return "redirect:/attachment/download?attachmentNo=" + attachmentNo;
}

** 250908

* primary key(member_id, attachment_no) 복합키

* 이미지 다운로드 방법
<img src = "/member/profile?memberId=${memberDto.getMemberId()}"
        		 width="200" height = "200">
application.properties

* 다운로드 용량 증가
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

-- DB와 연결
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=kh16
spring.datasource.password=kh16

-- DB 최적화
# dbcp (database connection pool)
spring.datasource.dbcp2.max-total=20
#spring.datasource.dbcp2.min-idle=5
spring.datasource.dbcp2.max-idle=5

@GetMapping("/profile")
public String Controller.profile(@RequestParam String memberId) 
{
	try 
	{
		int attachmentNo = memberDao.findAttachment(memberId);
		return "redirect:/attachment/download?attachmentNo=" + attachmentNo;			
	}
	catch(Exception e) 
	{
		return "redirect:/images/error/no-image.png";
	}
}

public void Dao.connect(String memberId, int attachmentNo) 
{
	String sql = "insert into member_profile (member_id, attachment_no) values (?, ?)";
	Object[] params = {
			memberId, 
			attachmentNo
	};//동적할당
	jdbcTemplate.update(sql, params);
}

public int Dao.findAttachment(String memberId) 
{
	String sql = "select attachment_no from member_profile where member_id = ?";
	Object[] params = {memberId};
	return jdbcTemplate.queryForObject(sql, int.class, params);
}


@Service // 각종 도구들을 주입하여 거대한 목표를 달성하기 위한 복잡한 코드를 메소드로 가지는 도구
// 상품구매 : 회원포인트 검사/차감 + 상품재고검사/차감 + 구매이력기록
public class AttachmentService 
{
	@Autowired
	private AttachmentDao attachmentDao;
	
	private File home = new File(System.getProperty("user.home"));
	private File upload = new File(home, "upload");
	
	@Transactional // 이 메소드를 하나의 트랜잭션으로 간주(이 안에서의 DB 작업은 일괄로 처리/취소)
	public int save(MultipartFile attach) throws IllegalStateException, IOException 
	{
		int attachmentNo = attachmentDao.sequence();
		
		if (upload.exists() == false) 
			upload.mkdirs();
		
		File target = new File(upload, String.valueOf(attachmentNo)); // 저장할 파일의 인스턴스
		attach.transferTo(target);
		
		AttachmentDto attachmentDto = new AttachmentDto();
		attachmentDto.setAttachmentNo(attachmentNo);
		attachmentDto.setAttachmentName(attach.getOriginalFilename());
		attachmentDto.setAttachmentType(attach.getContentType());
		attachmentDto.setAttachmentSize(attach.getSize());
		
		attachmentDao.insert(attachmentDto);
		
		return attachmentNo;
	}
	
	public ByteArrayResource load(int attachmentNo) throws IOException 
	{	
		// 파일의 정보 읽기
		File home = new File(System.getProperty("user.home"));
		File upload = new File(home, "upload");
		File target = new File(upload, String.valueOf(attachmentNo));
		
		if (!target.isFile())
			throw new TargetNotfoundException("존재하지 않는 파일");
		
		// java.nio 패키지의 명령
		byte[] data = Files.readAllBytes(target.toPath());
		ByteArrayResource resource = new ByteArrayResource(data);
		return resource;
	}
}

@Controller
@RequestMapping("/attachment")
public class AttachmentController 
{
	@Autowired
	private AttachmentService attachmentService;
	@Autowired
	private AttachmentDao attachmentDao;
	
	@GetMapping("/download")
	public ResponseEntity<ByteArrayResource> download(@RequestParam int attachmentNo) throws IOException 
	{
		// DB에서 정보 조회
		AttachmentDto attachmentDto = attachmentDao.selectOne(attachmentNo);
		if (attachmentDao == null)
			throw new TargetNotfoundException("존재하지 않는 파일");
		
		ByteArrayResource resource = attachmentService.load(attachmentNo);
		
		// 사용자에게 정보(header)와 내용(body)을 담아서 전송
		// 형태를 모르면 application/octet-stream
		// Content-Length는 전송할 파일의 크기
		// Content-Disposition는 body에 담긴 데이터를 어떻게 처리할지
		// inline 으로 작성하면 
		// attachment
//		return ResponseEntity.ok()
//				.header("Content-Encoding", "UTF-8") // 이건 UTF-8이다
//				.header("Content-Type", attachmentDto.getAttachmentType()) // db에 저장된 AttachmentType
//				.header("Content-Length", String.valueOf(attachmentDto.getAttachmentSize()))
//				.header("Content-Disposition", "attachment; filename=" + attachmentDto.getAttachmentName())
//				.body(resource);
		
		return ResponseEntity.ok()
				.header(HttpHeaders.CONTENT_ENCODING, StandardCharsets.UTF_8.name())
				.header(HttpHeaders.CONTENT_TYPE, attachmentDto.getAttachmentType())
				.contentLength(attachmentDto.getAttachmentSize())
				.header(HttpHeaders.CONTENT_DISPOSITION, 
						ContentDisposition.attachment().filename(attachmentDto.getAttachmentName(), StandardCharsets.UTF_8).build().toString())
				.body(resource);
	}
}

// 파일 삭제
public void delete(int attachmentNo) 
{
	AttachmentDto attachmentDto = attachmentDao.selectOne(attachmentNo);
	if (attachmentDto == null)
		throw new TargetNotfoundException("존재하지 않는 파일");
	
	// 실제 파일 삭제
	File target = new File(upload, String.valueOf(attachmentNo));
	target.delete();
	
	// DB 정보 삭제
	attachmentDao.delete(attachmentNo);
}

public boolean AttachmentService.delete(int attachmentNo) 
{
	String sql = "delete attachment where attachment_no = ?";
	Object[] params = {attachmentNo};
	return jdbcTemplate.update(sql, params) > 0;
}

// 첨부파일도 같이 삭제되도록 수정
// attachmentService.delete 추가
@RequestMapping("/remove")
public String Controller.remove(@RequestParam int pokemonNo)
{
	PokemonDto pokemonDto = pokemonDao.selectOne(pokemonNo);
	if (pokemonDto == null) 
	{
		throw new TargetNotfoundException("존재하지 않는 포켓몬 번호");
	}
	
	try 
	{
		int attachmentNo = pokemonDao.findAttachment(pokemonNo);
		attachmentService.delete(attachmentNo);
	}
	catch(Exception e) { /*아무것도 안함*/ }
	
	pokemonDao.delete(pokemonNo);
	return "redirect:list";
}

현재 프로필 없음 -> 변경 프로필 없음 : 유지
현재 프로필 없음 -> 변경 프로필 있음 : 저장
현재 프로필 있음 -> 변경 프로필 없음 : 유지
현재 프로필 있음 -> 변경 프로필 있음 : 삭제/저장

<form action = "edit" method = "post" enctype = "multipart/form-data"> 파일 전송시 필수

try 
{
	int attachmentNo = pokemonDao.findAttachment(pokemonNo);
	attachmentService.delete(attachmentNo);
}
catch(Exception e) { /*아무것도 안함*/ }

@PostMapping("/edit")
public String edit(@ModelAttribute PokemonDto pokemonDto,
		@RequestParam MultipartFile attach,
		@RequestParam(required = false) String remove) throws IllegalStateException, IOException 
{
	PokemonDto findDto = pokemonDao.selectOne(pokemonDto.getPokemonNo());
	if (findDto == null)
		throw new TargetNotfoundException("포켓몬 파일이 없음");
	
	if (!attach.isEmpty())
	{
		try 
		{
			int attachmentNo = pokemonDao.findAttachment(pokemonDto.getPokemonNo());
			attachmentService.delete(attachmentNo);
		}
		catch(Exception e) { /*아무것도 안함*/ }
		
		int attachmentNo = attachmentService.save(attach);
		pokemonDao.connect(pokemonDto.getPokemonNo(), attachmentNo);
	}
	else 
	{
		if (remove != null) 
		{
			try 
			{
				int attachmentNo = pokemonDao.findAttachment(pokemonDto.getPokemonNo());
				attachmentService.delete(attachmentNo);
			}
			catch(Exception e) { /*아무것도 안함*/ }
		}				
	}
	
	pokemonDao.update(pokemonDto);
	return "redirect:detail?pokemonNo=" + pokemonDto.getPokemonNo();
}

0drop table giftcard cascade constraint;
외래키의 제약조건으로 묶여도 삭제 가능

9,900원에 10,000 포인트 증정

<!-- error 파라미터가 있다면 오류 메세지 출력 -->
<c:if test = "${ param.error != null }">
	<h2 style = "color:red">입력하신 정보가 일치하지 않습니다.</h2>
</c:if>

<input type = "file" name = "attach" accept = "image/*" required>

giftcardNo=1&giftcardNo=2&giftcardNo=3
 -> @RequestParam(value = "giftcardNo") List<Integer> giftcardNoList

@GetMapping("/deleteAll")
public String deleteAll(@RequestParam(value = "giftcardNo") List<Integer> giftcardNoList) 
{
	for(int giftcardNo : giftcardNoList) 
	{
		GiftcardDto giftcardDto = giftcardDao.selectOne(giftcardNo);
		if (giftcardDto == null) 
			throw new TargetNotfoundException("존재하지 않는 상품권");
		
		try 
		{
			int attachmentNo = giftcardDao.findAttachment(giftcardNo);
			attachmentService.delete(attachmentNo);
		}
		catch(Exception e) { /*아무것도 안함*/ }		
		
		giftcardDao.delete(giftcardNo);
	}
	return "redirect:list";
}

** 250909

drop table giftcard_image;
create table giftcard_image (
giftcard_no references giftcard(giftcard_no) on delete cascade unique, // 외래키
attachment_no references attachment(attachment_no) on delete cascade unique, // 외래키
primary key(giftcard_no, attachment_no) // 복합키
);

구매 기록은 CR만 구현한다
CRUD를 하나 마냐에 따라 Dto, Dao, Mapper를 만들지 말지 정한다

drop table buy;
create table buy
(
	buy_no number primary key,
	buy_member_id varchar2(20) not null,
	buy_giftcard_no number not NULL,
	buy_giftcard_name varchar2(90) not null,
	buy_time TIMESTAMP default systimestamp not null,
	buy_qty number default 1 not null,
	buy_amount number not null,
	check(regexp_like(buy_member_id, '^[a-z][a-z0-9]{4,19}')),
	check(buy_qty > 0),
	check(buy_amount >= 0)
);

drop sequence buy_seq;
create sequence buy_seq;

* JSP에서 localhost의 경로 : ${pageContext.request.contextPath}

@Transactional // 이 메소드를 하나의 트랜잭션으로 간주(이 안에서의 DB 작업은 일괄로 처리/취소)

figma


@Component
public class Mapper implements RowMapper<Dto> {

	@Override
	public AttachmentDto mapRow(ResultSet rs, int rowNum) throws SQLException {
		Dto dto = new Dto();
		dto.set(rs.getInt("table_column"));
		
		return dto;
	}
}

@Repository
public class Dao 
{
	@Autowired
	private JdbcTemplate jdbcTemplate;
	@Autowired
	private Mapper mapper;
	
	public int sequence() 
	{
		String sql = "select seq.nextval from dual";
		return jdbcTemplate.queryForObject(sql, int.class);
	}

	public void insert(Dto dto) 
	{
		String sql = "insert into table (column) "
				+ "values (?)";
		Object[] params = { keyword };
		jdbcTemplate.update(sql, params);
	}

	public boolean update(Dto dto) 
	{
		String sql = "update table set column = ?";
    		Object[] params = { keyword };
    		return 0 < jdbcTemplate.update(sql, params);
	} 

	public boolean delete(int primaryKey)
	{
		String sql = "delete table where column=?";
    		Object[] params = { keyword };
    		return 0 < jdbcTemplate.update(sql, params);
	}

	public List<Dto> selectListWithPaging(PageVO pageVO) 
	{
		if(pageVO.isList()) 
		{	//목록이라면
			String sql = "select * from ("
					+ "select rownum rn, TMP.* from ("
						+ "select query"
					+ ")TMP"
				+ ") where rn between ? and ?";

			Object[] params = {
					pageVO.getBegin(), pageVO.getEnd()
			};//동적할당
			return jdbcTemplate.query(sql, Mapper, params);
		}
	}
}


@Data
public class PageVO 
{
	// 필드에 페이징에 필요한 데이터들을 배치
	private int page = 1; // 현재 페이지 번호
	private int size = 10; // 한 페이지에 표시할 데이터 수
	private String column, keyword; // 검색 항목
	private int dataCount; // 총 데이터 수
	private int blockSize = 10; // 표시할 블록 개수
	
	// 계산할 수 있는 Getter 메소드 추가 생성
	public boolean isSearch() 
	{
		return column != null && keyword != null;
	}
	
	public boolean isList() 
	{
		return column == null || keyword == null;	
	}
	
	public String getSearchParams() 
	{
		if (isSearch())
			return "size=" + size + "&column=" + column + "&keyword=" + keyword;
		else
			return "size=" + size;
	}
	
	public int getBlockStart() 
	{
		return (page - 1) / blockSize * blockSize + 1;	
	}
	
	public int getBlockFinish() 
	{
		int number = (page - 1) / blockSize * blockSize + blockSize;		
		return Math.min(getTotalPage(), number);
	}
	
	public int getTotalPage() 
	{
		return (dataCount - 1) / size + 1;
	}
	
	public int getBegin() 
	{
		return page * size - (size - 1);
	}
	
	public int getEnd() 
	{
		return page * size;
	}
	
	public boolean isFirstBlock() 
	{
		return getBlockStart() == 1;
	}
	
	public boolean isLastBlock() 
	{
		return getBlockFinish() == getTotalPage();
	}
	
	public int getPrevPage() 
	{
		return getBlockStart() - 1;
	}
	
	public int getNextPage() 
	{
		return getBlockFinish() + 1;
	}
}


다 고딕체를 쓴다 Sans serif
	- noto sans

monospace : 모든 글자가 일정한 폭을 가지는 글꼴
	- consola

** 250910

<!DOCTYPE html>
  - html의 버젼
 - 5가 최신
<html lang="ko">

VSCode 설치
live server lib 설치

설정법
f1 -> setting ui
commonly used -> font size
browser 검색 -> live server -> settings : custom browser -> chrome:PrivateMode
emmet 검색 -> emmet: variables -> value : ko

content="width=device-width, initial-scale=1.0"
기기의 해상도에 폭을 맞추고 최초 1배로 화면을 띄워라

git 설치

설치 확인
git --version

git 연동법
 -> 
git config --global user.name "NDDYLYS"
git config --global user.email "nodvic@naver.com"

설정 확인
git config --global user.name
git config --global user.email

github pull requests 설치
f1 -> clone 안 나오면 재시작

f1 -> commit all
comment 입력, 저장, 닫기
f1 -> pull
f1 -> push

f1 -> setting json
{
    "workbench.colorTheme": "Default Light Modern",
    "editor.fontSize": 20,
    "liveServer.settings.CustomBrowser": "chrome:PrivateMode",
    "emmet.variables": {
        "lang": "ko"
    }
}

ctrl + / 주석

이름과 항목을 :으로 연결
<input style = "">

한 명령어의 마지막에 ; 적기

장점 : 어떤 방식보다의 디자인보다도 우선순위가 높다
단점 : 알아보기가 힘들다(가독성이 낮다)

메인 디자인이 아니라 중요한 몇 가지만 설정할 때 쓴다

style 태그를 사용하여 디자인 선택자(selector)를 이용하여 대상을 지정
장점 : 가독성이 좋다, 재사용 가능
단점 : 선택자를 공부해야 한다

이 방식을 메인 디자인으로 채택
(style은 화면에 안 나오므로 head에 넣는다)
<style>
        input {
            font-size:50px;
        }
</style>

<input id="nameInput" type="text" placeholder="이름">
<input id="emailInput" type="email" placeholder="이메일">

<style>
  #nameInput {
    border: 2px solid red;
    background: #ffeaea;
  }
  #emailInput {
    border: 2px solid blue;
    background: #eaf0ff;
  }
</style>

font-family: 'Times New Roman', Times, serif;
폰트가 없으면 오른쪽껄 실행한다

margin은 100%에 포함되지 않는다.
위 아래만 주기도 한다

상하 / 좌우
margin: 10px 0px;

12시 3시 6시 9시
 margin: 10px 0px 20px 40px;

<b>볼드</b>
<strong>더 강한 볼드</strong>

    <style>
        /* 태그 선택자 */
        input {
            /* 색상 관련 */
            color:#ffaa66; /* 글자색 */
            background-color: transparent;/* 배경색 */
            /* 테두리 관련 디자인 */
            border-color: green;
            border-style: solid;
            border-width: 7px;
            /* border : 3px solid  */
            border-radius: 99px;/* 모서리를 깎는다 */

            /* 글꼴 관련 디자인 */
            font-family: 'Times New Roman', Times, serif;
            /* 폰트가 없으면 오른쪽껄 실행한다 */
            font-size: 20px;
            font-weight: 100 /*가중치*/ ;
            font-style:italic;

            /* 여백과 크기 디자인 */
            padding: 10px;
            margin: 10px;
            margin: 10px 0px;
            /* 
            margin은 100%에 포함되지 않는다.
            위 아래만 주기도 한다

            상하 / 좌우
            margin: 10px 0px;

            12시 3시 6시 9시
            margin: 10px 0px 20px 40px; */
        }
    </style>

1. <br> 없이 줄바꿈
2. 입력창하고 버튼의 폭이 안 맞음
3. 글자 크기에 비례한 크기 지정
4. 태그별로 디자인 해야 하나?

display:block;
위 아래로 점점 쌓인다, 한줄에 한개만 배치
폭(width) 설정 가능
display:inline;
한 줄에 여러 개 배치 
폭 설정 불가능

1 -> display:inline-block;

2 -> * {
	box-sizing: border-box;
}

3 -> padding:0.5em;

<div style="text-align:center;">

margin을 중앙 정렬에 주기
autocommit

<img src = "images/Instagram_logo.svg.png">
자기 스크립트 경로 내 상대경로로 적용

border:none;
테두리 제거

text-decoration: none;
a 태그에서 밑줄 제거

전지적 역할 관점

로고 logo
입력창 field
버튼 btn
구분선 divider
링크 link

class 디자인적인 역할

.Container
.cell

한 줄에 cell은 하나다

* {
	box-sizing: border-box;
}
div{
	box-shadow: 0 0 1px 0 gray;
}
